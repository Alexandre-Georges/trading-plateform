<html>
    <head>
        <title>Finance</title>
        <link rel="stylesheet" href="style.css">
        <script src="jquery-2.2.0.min.js"></script>
        <script src="d3fc.bundle.js"></script>
        <link href="d3fc.css" rel="stylesheet" />
        <script src="moment.js"></script>
    </head>
    <body class="main">
        <div id="impulse-multi" class="chart"></div>
        <div id="daily-multi" class="chart"></div>
        <div id="daily-volume" class="chart"></div>
        <div id="daily-macd" class="chart"></div>
        <div id="weekly-multi" class="chart"></div>
        <div id="weekly-volume" class="chart"></div>
        <div id="weekly-macd" class="chart"></div>

        <table>
            <tr>
                {{#each data}}
                    <td>{{this.date}}</td>
                {{/each}}
            </tr>
            <tr>
                {{#each data}}
                    <td>{{this.impulse}}</td>
                {{/each}}
            </tr>
        </table>
    </body>

    <script type="text/javascript">

        var formats = {
            shortDateFormat: d3.time.format('%d/%m/%Y'),
            dateFormat: d3.time.format('%a %d %b %Y'),
            priceFormat: d3.format('.2f'),
            volumeFormat: d3.format(',')
        };

        var pointSnapper = {
            pointSnap: function(xScale, yScale, xValue, yValue, data, objectiveFunction) {
                // a default function that computes the distance between two points
                objectiveFunction = objectiveFunction || function(x, y, cx, cy) {
                            var dx = x - cx,
                                    dy = y - cy;
                            return dx * dx + dy * dy;
                        };

                return function(xPixel, yPixel) {
                    var filtered = data.filter(function(d, i) {
                        return fc.util.fn.defined(xValue, yValue)(d, i);
                    });

                    var nearest = fc.util.minimum(filtered, function(d) {
                        return objectiveFunction(xPixel, yPixel, xScale(xValue(d)), yScale(yValue(d)));
                    })[1];

                    return {
                        datum: nearest,
                        x: nearest ? xScale(xValue(nearest)) : xPixel,
                        // uppdated code here
                        y: yPixel
                    };
                };
            },
            seriesPointSnap: function (series, data, objectiveFunction) {
                var self = this;
                return function(xPixel, yPixel) {
                    var xScale = series.xScale(),
                            yScale = series.yScale(),
                            xValue = series.xValue(),
                            yValue = (series.yValue || series.yCloseValue).call(series);
                    return self.pointSnap(xScale, yScale, xValue, yValue, data, objectiveFunction)(xPixel, yPixel);
                };
            },
            seriesPointSnapXOnly: function (series, data) {
                function objectiveFunction(x, y, cx, cy) {
                    var dx = x - cx;
                    return Math.abs(dx);
                }
                return this.seriesPointSnap(series, data, objectiveFunction);
            }
        };

        var config = {
            indicators: {
                shortEMA: {
                    name: 'shortEMA',
                    colour: '#ffc600'
                },
                longEMA: {
                    name: 'longEMA',
                    colour: '#c87a00'
                },
                macd: {
                    positiveBarColour: '#6c0',
                    negativeBarColour: '#c60'
                }
            },
            display: {
                crosshair: {
                    verticalGap: 20,
                    horizontalGap: 20
                },
                graph: {
                    width: 1500,
                    mainGraph: {
                        height: 250
                    },
                    volumeGraph: {
                        height: 100
                    },
                    macdGraph: {
                        height: 200
                    },
                    impulseGraph: {
                        height: 70
                    }
                }
            }
        };

        var algoBuilder = {
            getXScale: function (data) {
                return fc.scale.dateTime()
                        .domain(fc.util.extent().pad(0.1).fields(['date'])(data))
                        .range([20, config.display.graph.width - 50]);
            },
            getYScale: function (domain, range) {
                return d3.scale.linear().domain(domain).range(range);
            }
        };

        var indicatorBuilder = {
            getMovingAverage: function (config) {
                return fc
                    .series.line()
                    .xValue(function(dataPoint) { return dataPoint.date; })
                    .yValue(function(dataPoint) { return dataPoint[config.name]; })
                    .decorate(function(g) {
                        g
                            .enter()
                            .style('stroke', function() {
                                return config.colour;
                            });
                    });
            },
            getEnvelope: function () {
                return fc.indicator.renderer.envelope();
            },
            getMACD: function (xScale, yScale) {

                return fc.indicator.renderer.macd()
                        .xScale(xScale)
                        .yScale(yScale)
                        .decorate(function(g) {
                            var previousDivergence = null;
                            g
                                .enter()
                                .selectAll('.bar > path')
                                .style('fill', function(dataPoint, index) {
                                    var colour = config.indicators.macd.positiveBarColour;
                                    if (index === 0 && dataPoint.macd.divergence < 0 || previousDivergence > dataPoint.macd.divergence) {
                                        colour = config.indicators.macd.negativeBarColour;
                                    }
                                    previousDivergence = dataPoint.macd.divergence;
                                    return colour;
                                }).style('stroke', 'transparent');
                        });
            },
            getCrosshair: function (data, xScale, yScale, renderCrosshair) {

                var crosshairLine = fc.series.line()
                        .xValue(function(dataPoint) { return dataPoint.date; })
                        .yValue(function(dataPoint) { return dataPoint.date; })
                        .xScale(xScale)
                        .yScale(yScale);

                return crosshair = fc.tool.crosshair()
                        .snap(pointSnapper.seriesPointSnapXOnly(crosshairLine, data))
                        .xLabel(function() { return ''; })
                        .yLabel(function(dataPoint) { return formats.priceFormat(yScale.invert(dataPoint.y)); })
                        .on('trackingstart', renderCrosshair)
                        .on('trackingmove', renderCrosshair)
                        .on('trackingend', renderCrosshair);
            },
            getTooltip: function (items, width, heigth) {
                var tooltip = fc.chart.tooltip().items(items);

                var tooltipContainer = fc.tool.container()
                        .padding(5)
                        .component(tooltip);

                return fc.layout.label(fc.layout.strategy.removeOverlaps())
                        .size([width, heigth])
                        .component(tooltipContainer);
            },
            addXAxis: function (xScale, yTranslation, container) {
                var axis = d3.svg.axis()
                        .scale(xScale)
                        .ticks(5)
                        .orient('bottom')
                        .tickFormat(formats.shortDateFormat);

                container.append('g')
                        .attr('class', 'axis')
                        .attr('transform', 'translate(0, ' + yTranslation + ')')
                        .call(axis);
            },
            addYAxis: function (yScale, ticks, xTranslation, container) {
                var axis = d3.svg.axis()
                        .scale(yScale)
                        .ticks(ticks)
                        .orient('right');

                container.append('g')
                        .attr('class', 'axis')
                        .attr('transform', 'translate(' + xTranslation + ', 0)')
                        .call(axis);
            }
        };

        function buildMainChart(selector, data) {

            var container = d3.select(selector)
                    .append('svg')
                    .attr({'width': config.display.graph.width, 'height': config.display.graph.mainGraph.height});

            var xScale = algoBuilder.getXScale(data);
            var yScale = algoBuilder.getYScale(fc.util.extent().pad(0.2).fields(['high', 'low'])(data), [config.display.graph.mainGraph.height - 30, 20]);

            var candlestick = fc.series.candlestick();
            var gridlines = fc.annotation.gridline();

            var shortMovingAverageLine = indicatorBuilder.getMovingAverage(config.indicators.shortEMA);
            var movingAverageEnvelope = indicatorBuilder.getEnvelope();
            var longMovingAverageLine = indicatorBuilder.getMovingAverage(config.indicators.longEMA);

            var tooltipLayout = indicatorBuilder.getTooltip([
                ['Date :', function (dataPoint) { return formats.dateFormat(dataPoint.datum.date); }],
                ['Open :', function (dataPoint) { return formats.priceFormat(dataPoint.datum.open); }],
                ['Close :', function (dataPoint) { return formats.priceFormat(dataPoint.datum.close); }],
                ['High :', function (dataPoint) { return formats.priceFormat(dataPoint.datum.high); }],
                ['Low :', function (dataPoint) { return formats.priceFormat(dataPoint.datum.low); }],
                ['Short EMA :', function (dataPoint) { if (!dataPoint.datum[config.indicators.shortEMA.name]) { return ''; } return formats.priceFormat(dataPoint.datum[config.indicators.shortEMA.name]); }],
                ['Long EMA :', function (dataPoint) { if (!dataPoint.datum[config.indicators.longEMA.name]) { return ''; } return formats.priceFormat(dataPoint.datum[config.indicators.longEMA.name]); }]
            ], 200, 100);

            var crosshair = indicatorBuilder.getCrosshair(data, xScale, yScale, function (dataPoints) {
                if (dataPoints.length > 0) {
                    tooltipLayout.position([dataPoints[0].x + config.display.crosshair.horizontalGap, dataPoints[0].y + config.display.crosshair.verticalGap]);
                    container
                        .datum(data)
                        .call(multi);
                }
            });

            var crosshairData = [];
            var multi = fc.series.multi()
                    .series([gridlines, movingAverageEnvelope, candlestick, shortMovingAverageLine, longMovingAverageLine, crosshair, tooltipLayout])
                    .xScale(xScale)
                    .yScale(yScale)
                    .mapping(function(series) {
                        switch (series) {
                            case crosshair:
                            case tooltipLayout:
                                return crosshairData;
                            default:
                                return this;
                        }
                    });

            indicatorBuilder.addXAxis(xScale, config.display.graph.mainGraph.height - 20, container);
            indicatorBuilder.addYAxis(yScale, 5, config.display.graph.width - 40, container);

            container.append('g')
                    .datum(data)
                    .call(multi);
        }

        function buildVolume(selector, data) {

            var container = d3.select(selector)
                    .append('svg')
                    .attr({'width': config.display.graph.width, 'height': config.display.graph.volumeGraph.height, "style": "padding: 20px 0;"});

            var xScale = algoBuilder.getXScale(data);
            var yScale = algoBuilder.getYScale([0, d3.max(data, function (dataPoint) { return dataPoint.volume; }) * 1.3], [config.display.graph.volumeGraph.height, 0]);

            var volume = fc.series.bar()
                    .xValue(function (dataPoint) { return dataPoint.date; })
                    .yValue(function (dataPoint) { return dataPoint.volume; })
                    .decorate(function (g) {
                        var previousValue = null;
                        g
                            .enter()
                            .selectAll('.bar > path')
                            .style('fill', function (dataPoint) {
                                var colour = '#6c0';
                                if (previousValue > dataPoint.volume) {
                                    colour = '#c60';
                                }
                                previousValue = dataPoint.volume;
                                return colour;
                            }).style('stroke', 'transparent');
                    });

            var gridlines = fc.annotation.gridline();

            var tooltipLayout = indicatorBuilder.getTooltip([
                ['Date :', function (dataPoint) { return formats.dateFormat(dataPoint.datum.date); }],
                ['Volume :', function (dataPoint) { return formats.volumeFormat(dataPoint.datum.volume).replace(/,/g, ' '); }]
            ], 195, 40);

            var crosshair = indicatorBuilder.getCrosshair(data, xScale, yScale, function (dataPoints) {
                if (dataPoints.length > 0) {
                    tooltipLayout.position([dataPoints[0].x + config.display.crosshair.horizontalGap, dataPoints[0].y + config.display.crosshair.verticalGap]);
                    container
                        .datum(data)
                        .call(multi);
                }
            });

            var crosshairData = [];

            var multi = fc.series.multi()
                    .series([gridlines, volume, crosshair, tooltipLayout])
                    .xScale(xScale)
                    .yScale(yScale)
                    .mapping(function(series) {
                        switch (series) {
                            case crosshair:
                            case tooltipLayout:
                                return crosshairData;
                            default:
                                return this;
                        }
                    });

            indicatorBuilder.addXAxis(xScale, config.display.graph.volumeGraph.height, container);
            indicatorBuilder.addYAxis(yScale, 4, config.display.graph.width - 50, container);

            container.append('g')
                    .datum(data)
                    .call(multi);
        }

        function buildMACD(selector, data) {

            var container = d3.select(selector)
                    .append('svg')
                    .attr({'width': config.display.graph.width, 'height': config.display.graph.macdGraph.height, "style": "padding: 20px 0;"});

            var xScale = algoBuilder.getXScale(data);
            var yScale = algoBuilder.getYScale(fc.util.extent().fields([function(dataPoint) { return dataPoint.macd.macd; }]).symmetricalAbout(0)(data), [ config.display.graph.macdGraph.height, 0 ]);

            var macd = indicatorBuilder.getMACD(xScale, yScale);

            var tooltipLayout = indicatorBuilder.getTooltip([
                ['Date : ', function (dataPoint) { return formats.dateFormat(dataPoint.datum.date); }],
                ['MACD :', function (dataPoint) { return formats.priceFormat(dataPoint.datum.macd.macd); }],
                ['Signal :', function (dataPoint) { return formats.priceFormat(dataPoint.datum.macd.signal); }],
                ['Divergence :', function (dataPoint) { return formats.priceFormat(dataPoint.datum.macd.divergence); }]
            ], 195, 80);

            var crosshair = indicatorBuilder.getCrosshair(data, xScale, yScale, function (dataPoints) {
                if (dataPoints.length > 0) {
                    tooltipLayout.position([dataPoints[0].x + config.display.crosshair.horizontalGap, dataPoints[0].y + config.display.crosshair.verticalGap]);
                    container
                        .datum(data)
                        .call(multi);
                }
            });

            var crosshairData = [];

            var multi = fc.series.multi()
                    .series([macd, crosshair, tooltipLayout])
                    .xScale(xScale)
                    .yScale(yScale)
                    .mapping(function(series) {
                        switch (series) {
                            case crosshair:
                            case tooltipLayout:
                                return crosshairData;
                            default:
                                return this;
                        }
                    });

            indicatorBuilder.addXAxis(xScale, config.display.graph.macdGraph.height, container);
            indicatorBuilder.addYAxis(yScale, 4, config.display.graph.width - 50, container);

            container.append('g')
                    .datum(data)
                    .call(multi);
        }

        function buildImpulse(selector, dailyData, weeklyData) {

            var fullData = [];

            var dailyIndex = 0;
            var weeklyIndex = 0;

            var nextWeeklyData = weeklyData[weeklyIndex];
            var lastWeeklyDataInserted = null;

            while (dailyIndex < dailyData.length) {
                var currentDailyData = dailyData[dailyIndex];

                if (nextWeeklyData && moment(currentDailyData.date).isSame(nextWeeklyData.date)) {
                    lastWeeklyDataInserted = {
                        date: nextWeeklyData.date,
                        impulse: nextWeeklyData.impulse ? nextWeeklyData.impulse.colour : null,
                        y: 2
                    };
                    weeklyIndex++;
                    nextWeeklyData = weeklyIndex < weeklyData.length ? weeklyData[weeklyIndex] : null;
                }

                fullData.push({
                    date: currentDailyData.date,
                    weeklyImpulse: lastWeeklyDataInserted.impulse,
                    dailyImpulse: currentDailyData.impulse ? currentDailyData.impulse.colour : null
                });

                dailyIndex++;
            }

            var container = d3.select(selector)
                .append('svg')
                .attr({'width': config.display.graph.width, 'height': config.display.graph.impulseGraph.height, "style": "padding: 20px 0;"});

            var xScale = algoBuilder.getXScale(fullData);
            var yScale = algoBuilder.getYScale([ 0, 4 ], [ config.display.graph.impulseGraph.height, 0 ]);

            var dailyPoint = fc.series.point()
                    .xValue(function(dataPoint) { return dataPoint.date; })
                    .yValue(function(dataPoint) { return dataPoint.dailyImpulse ? 1 : null; })
                    .size(function() {
                        return 40;
                    })
                    .type(function() {
                        return 'square';
                    })
                    .decorate(function (g) {
                        g
                            .enter()
                            .selectAll('.point > path')
                            .style('fill', function (dataPoint) {
                                return dataPoint.dailyImpulse;
                            }).style('stroke', 'transparent');
                    });

            var weeklyPoint = fc.series.point()
                    .xValue(function(dataPoint) { return dataPoint.date; })
                    .yValue(function(dataPoint) { return dataPoint.weeklyImpulse ? 2 : null; })
                    .size(function() {
                        return 40;
                    })
                    .type(function() {
                        return 'square';
                    })
                    .decorate(function (g) {
                        g
                            .enter()
                            .selectAll('.point > path')
                            .style('fill', function (dataPoint) {
                                return dataPoint.weeklyImpulse;
                            }).style('stroke', 'transparent');
                    });

            var tooltipLayout = indicatorBuilder.getTooltip([
                ['Date : ', function (dataPoint) { return formats.dateFormat(dataPoint.datum.date); }],
                ['Weekly Impulse : ', function (dataPoint) { return dataPoint.datum.weeklyImpulse; }],
                ['Daily Impulse : ', function (dataPoint) { return dataPoint.datum.dailyImpulse; }]
            ], 220, 50);

            var crosshair = indicatorBuilder.getCrosshair(fullData, xScale, yScale, function (dataPoints) {
                if (dataPoints.length > 0) {
                    tooltipLayout.position([dataPoints[0].x + config.display.crosshair.horizontalGap, dataPoints[0].y + config.display.crosshair.verticalGap]);
                    container
                        .datum(fullData)
                        .call(multi);
                }
            });

            var crosshairData = [];

            var multi = fc.series.multi()
                .series([ dailyPoint, weeklyPoint, crosshair, tooltipLayout ])
                .xScale(xScale)
                .yScale(yScale)
                .mapping(function(series) {
                    switch (series) {
                        case crosshair:
                        case tooltipLayout:
                            return crosshairData;
                        default:
                            return this;
                    }
                });

            indicatorBuilder.addXAxis(xScale, config.display.graph.impulseGraph.height, container);

            container.append('g')
                    .datum(fullData)
                    .call(multi);
        }

        var dailyData = JSON.parse('{{{this.dailyDataString}}}');
        for(let piece of dailyData) {
            piece.date = new Date(piece.date);
        }

        buildMainChart('#daily-multi', dailyData);
        buildVolume('#daily-volume', dailyData);
        buildMACD('#daily-macd', dailyData);



        var weeklyData = JSON.parse('{{{this.weeklyDataString}}}');
        for(let piece of weeklyData) {
            piece.date = new Date(piece.date);
        }

        buildImpulse('#impulse-multi', dailyData, weeklyData);
        buildMainChart('#weekly-multi', weeklyData);
        buildVolume('#weekly-volume', weeklyData);
        buildMACD('#weekly-macd', weeklyData);
        //END

    </script>
</html>